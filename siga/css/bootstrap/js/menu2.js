/ *
 Direitos autorais (C) Federico Zivolo 2018
 Distribuído sob a licença MIT (os termos da licença estão em http://opensource.org/licenses/MIT).
 * / (function (e, t) {'objeto' == tipo de exportações && 'indefinido'! = tipo de módulo? module.exports = t (): 'função' == tipo de definição && define.amd? define (t): e. Popper = t ()}) (this, function () {'use strict'; function e (e) {return e && '[objeto Function]' === {}. ToString.call (e)} function t (e , t) {if (1! == e.nodeType) return []; var o = getComputedStyle (e, null); return t? o [t]: o} função o (e) {return'HTML '== = e.nodeName? e: e.parentNode || e.host} função n (e) {if (! e) retorna document.body; switch (e.nodeName) {case'HTML ': case'BODY': return e.ownerDocument.body; case '# document': return e.body;} var i = t (e), r = i.overflow, p = i.overflowX, s = i.overflowY; return / (auto | scroll | overlay) /. test (r + s + p)? e: n (o (e))} função r (e) {if (! e) retorna document.documentElement; for (var o = ie (10)? document.body: null, n = e.offsetParent; n === o && e.nextElementSibling;) n = (e = e.nextElementSibling) .offsetParent; var i = n && n.nodeName; return i && 'BODY'! == i && 'HTML'! == i? -1! == ['TD' , 'TABLE']. IndexOf (n.nodeName) && 'static' === t (n, 'position')? R (n): n: e? E.ownerDocument.documentElement: document.documentElement} função p ( e) {var t = e.nodeName; return'BODY '! == t && (' HTML '=== t || r (e.firstElementChild) === e)} função s (e) {return null == = e.parentNode? e: s (e.parentNode)} função d (e, t) {if (! e ||! e.nodeType ||! t ||! t.nodeType) return document.documentElement; var o = e.compareDocumentPosition (t) & Node.DOCUMENT_POSITION_FOLLOWING, n = o? e: t, i = o? t: e, a = document.createRange (); a.setStart (n, 0), a.setEnd (i, 0); var l = a.commonAncestorContainer; if (e! == l && t! == l || n.contains (i)) retorna p (l)? L: r (l); var f = s (e) ; retornar f.host?d(f.host,t): d (e, s (t) .host)} função a (e) {var t = 1 <argumentos.length && void 0! == argumentos [1]? argumentos [1]: 'top', o = ' top '=== t?' scrollTop ':' scrollLeft ', n = e.nodeName; if (' BODY '=== n ||' HTML '=== n) {var i = e.ownerDocument.documentElement, r = e.ownerDocument.scrollingElement || i; return r [o]} return e [o]} função l (e, t) {var o = 2 <argumentos.length && void 0! == argumentos [2] && argumentos [2 ], n = a (t, 'superior'), i = a (t, 'esquerda'), r = o? -1: 1; return e.top + = n * r, e.bottom + = n * r, e.left + = i * r, e.right + = i * r, e} função f (e, t) {var o = 'x' === t? 'Esquerda': 'Superior', n = 'Esquerda' == o? 'Right': 'Bottom'; retornar parseFloat (e ['borda' + o + 'Largura'], 10) + parseFloat (e ['borda' + n + 'Largura'], 10)} function m ( e, t, o, n) {retorna Q (t ['deslocamento' + e], t ['rolagem' + e], o ['cliente '+ e], o [' deslocamento '+ e], o [' rolagem '+ e], ou seja, (10)? o [' deslocamento '+ e] + n [' margem '+ (' Altura '== = e? 'Superior': 'Esquerda')] + n ['margem' + ('Altura' === e? 'Inferior': 'Direita')]: 0)} função h () {var e = document .body, t = document.documentElement, o = ie (10) && getComputedStyle (t); return {height: m ('Altura', e, t, o), width: m ('Largura', e, t, o )}} função c (e) {return de ({}, e, {direita: e.left + e.width, inferior: e.top + e.height})} função g (e) {var o = { }; tente {if (ie (10)) {o = e.getBoundingClientRect (); var n = a (e, 'top'), i = a (e, 'left'); o.top + = n, o .left + = i, o.bottom + = n, o.right + = i} else o = e.getBoundingClientRect ()} catch (t) {} var r = {left: o.left, em cima: o.top, largura: o.right-o.left, height: o.bottom-o.top}, p = 'HTML' === e.nodeName? h (): {}, s = p.width || e.clientWidth || r.right-r.left, d = p.height || e.clientHeight || r.bottom-r.top, l = e.offsetWidth-s, m = e.offsetHeight-d; se (l || m) {var g = t (e); l- = f (g, 'x'), m- = f (g, 'y'), r.largura- = l, r.altura- = m} retornar c (r)} função u (e, o) {vari = 2 < argumentos.length && void 0! == argumentos [2] && argumentos [2], r = ie (10), p = 'HTML' === o.nodeName, s = g (e), d = g (o), a = n (e), f = t (o), m = parseFloat (f.borderTopWidth, 10), h = parseFloat (f.borderLeftWidth, 10); i && 'HTML' === o.nodeName && (d.top = Q (d.top, 0), d.left = Q (d.left, 0)); var u = c ({top: s.top-d.top-m, esquerda: s.left-d.left -h, width: s.width, height: s.height}); if (u.marginTop = 0, u.marginLeft = 0,! r && p) {var b = parseFloat (f.marginTop, 10), y = parseFloat (f.marginLeft, 10); u.top- = mb, u.bottom- = mb, u.left- = hy, u.right- = hy, u.marginTop = b, u.marginLeft = y} return ( r &&! i? o. contém (a): o === a && 'CORPO'! == a.nodeName) && (u = l (u, o)),u} função b (e) {var t = 1 <argumentos.length && vazio 0! == argumentos [1] && argumentos [1], o = e.ownerDocument.documentElement, n = u (e, o), i = Q ( o.clientWidth, window.innerWidth || 0), r = Q (o.clientHeight, window.innerHeight || 0), p = t? 0: a (o), s = t? 0: a (o, ' À esquerda '), d = {top: pn.top + n.marginTop, esquerda: sn.left + n.marginLeft, largura: i, altura: r}; retorna c (d)} função y (e) {var n = e.nodeName; return'BODY '=== n ||' HTML '=== n?! 1:' fixo '=== t (e,' posição ') || y (o (e))} função w (e) {if (! e ||! e.parentElement || ie ()) retorna document.documentElement; for (var o = e.parentElement; o && 'none' === t (o, 'transform') );) o = o.parentElement; return o || document.documentElement} função E (e, t, i, r) {var p = 4 <argumentos.length && void 0! == argumentos [4] && argumentos [4], s = {top: 0, esquerda: 0}, a = p? w (e): d (e, t); if ('viewport' === r) s = b (a, p);else {var l; 'scrollParent' === r? (l = n (o (t)), 'BODY' === l.nodeName && (l = e.ownerDocument.documentElement)): 'window' === r? l = e.ownerDocument.documentElement: l = r; var f = u (l, a, p); if ('HTML' === l.nodeName &&! y (a)) {var m = h () , c = m.height, g = m.width; s.top + = f.top-f.marginTop, s.bottom = c + f.top, s.left + = f.left-f.marginLeft, s.right = g + f.left} else s = f} retorna s.left + = i, s.top + = i, s.right- = i, s.bottom- = i, s} função v (e) {var t = e.width, o = e.height; return t * o} função x (e, t, o, n, i) {var r = 5 <argumentos.length && void 0! == argumentos [5]? argumentos [5] : 0; if (-1 === e.indexOf ('auto')) retorna e; var p = E (o, n, r, i), s = {top: {width: p.width, height: t.top-p.top}, direita: {width: p.right-t.right, altura: p.height}, inferior: {width: p.width, height: p.bottom-t.bottom}, esquerda : {width: t.left-p.left, height: p.height}}, d = Object.keys (s) .map (função (e) {return de ({key: e},s [e], {área: v (s [e])})}). sort (função (e, t) {retorna t.area-e.area}), a = d.filter (função (e) {var t = e.width, n = e.height; return t> = o.clientWidth && n> = o.clientHeight}), l = 0 <comprimento.a [0] .key: d [0] .key , f = e.split ('-') [1]; retorna l + (f? '-' + f: '')} função O (e, t, o) {var n = 3 <argumentos.length && void 0! == argumentos [3]? argumentos [3]: nulo, i = n? w (t): d (t, o); retorna u (o, i, n)} função L (e) {var t = getComputedStyle (e), o = parseFloat (t.marginTop) + parseFloat (t.marginBottom), n = parseFloat (t.marginLeft) + parseFloat (t.marginRight), i = {width: e.offsetWidth + n, height: e .offsetHeight + o}; return i} função S (e) {var t = {left: 'right', right: 'left', bottom: 'top', top: 'bottom'}; return e.replace (/ left | right | bottom | top / g, função (e) {return t [e]})} função T (e, t, o) {o = o.split ('-') [0]; var n = L (e), i = {largura: n. Largura, altura: n.altura}, r = -1! == ['direita', 'esquerda']. indexOf (o), p = r? 'superior': 'esquerda', s = r? 'esquerda': 'superior', d = r? 'height': 'width', a = r? 'width': 'height'; retorno i [p] = t [p] + t [d] / 2-n [d] / 2, i [ s] = o === s? t [s] -n [a]: t [S (s)], i} função D (e, t) {retornar Array.prototype.find? e.find (t) : e.filter (t) [0]} função C (e, t, o) {if (Array.prototype.findIndex) retorna e.findIndex (função (e) {retorna e [t] === o}) ; var n = D (e, função (e) {retornar e [t] === o}); retornar e.indexOf (n)} função N (t, o, n) {vari = vazio 0 == = n? t: t.slice (0, C (t, 'name', n)); return i.forEach (function (t) {t ['function'] && console.warn ('' modifier.function` é obsoleto, use `modifier.fn`! '); var n = t [' function '] || t.fn; t.enabled && e (n) && (o.offsets.popper = c (o.offsets.popper), o.offsets.reference = c (o.offsets.reference), o = n (o, t))}),o} função k () {if (! this.state.isDestroyed) {var e = {instance: this, styles: {}, arrowStyles: {}, atributos: {}, invertido:! 1, offsets: {}} ; e.offsets.reference = O (este estado, este.popper, esta.referência, esta.opções.posiçãoFixada), e.placement = x (esta.opções.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets.popper = T (this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed? 'Fixed': 'absolute', e = N (this.modifiers, e), this .state.isCreated? this.options.onUpdate (e) :( this.state.isCreated =! 0, this.options.onCreate (e))}} função P (e, t) {return e.some (function ( e) {var o = e.name, n = e.enabled; retorna n && o === t})} função W (e) {for (var t = [! 1, 'ms ',' Webkit ',' Moz ',' O '], o = e.charAt (0) .toUpperCase () + e.slice (1), n ​​= 0; n <comprimento.t; n ++) {var i = t [n], r = i? '' + i + o: e; if ('indefinido'! = tipo de documento.body.style [r]) retornar r} retornar nulo} função B () {retornar este .state.isDestroyed =! 0, P (this.modifiers, 'applyStyle') && (this.popper.removeAttribute ('x-placement'), this.popper.style.position = '', this.popper.style. top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', este .popper.style [W ('transform')] = ''), this.disableEventListeners (), this.options.removeOnDestroy && this.popper.parentNode.removeChild (this.popper), esta} função H (e) {var t = e.ownerDocument; retorna t? t.defaultView: window} função A (e, t, o, i) {var r = 'BODY '=== e.nodeName, p = r? E.ownerDocument.defaultView: e; p.addEventListener (t, o, {passivo:! 0}), r || A (n (p.parentNode), t , o, i), i.push (p)} função I (e, t, o, i) {o.updateBound = i, H (e) .addEventListener ('redimensionar', o.updateBound, {passive :! 0}); var r = n (e); retorna A (r, 'scroll', o.updateBound, o.scrollParents), o.scrollElement = r, o.eventsEnabled =! 0, o} função M () { this.state.eventsEnabled || (this.state = I (this.reference, this.options, this.state, this.scheduleUpdate))} função F (e, t) {retornar H (e) .removeEventListener ('redimensionar ', t.updateBound), t.scrollParents.forEach (function (e) {e.removeEventListener (' scroll ', t.updateBound)}), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled =! 1, t} função R () {this.state.eventsEnabled && (cancelAnimationFrame (this.scheduleUpdate)), this.state = F (this.reference, this.state))} function U (e) {return ''! == e &&! isNaN (parseFloat (e)) && isFinite (e)} função Y (e, t) {Object.keys (t) .forEach (function (o ) {var n = ''; - 1! == ['largura', 'altura', 'superior', 'direita', 'inferior', 'esquerda']. indexOf (o) && U (t [o]) && (n = 'px'), e.style [o] = t [o] + n})} função j (e, t) {Object.keys (t) .forEach (function (o) {var n = t [o] ;! 1 === n? e.removeAttribute (o): e.setAttribute (o, t [o])})} função q (e, t, o) {var n = D (e, função (e) {var o = e.name; return o === t}), i = !! n && e.some (função (e) {return e.name === o && e.enabled && e.order <n.order }); if (! i) {var r = '' '+ t +' ''; console.warn ('' '+ o +' '' + 'modificador é exigido pelo modificador' + r + 'para funcionar, seja certifique-se de incluí-lo antes de '+ r +'! ')} retornar i} função K (e) {retornar'fim '=== e?' start ':' start '=== e?' end ': e} função V (e) {var t = 1 <argumentos.length && void 0! == argumentos [1] && argumentos [1 ], o = le.indexOf (e), n = le.slice (o + 1) .concat (le.slice (0, o)); retorna t? n.reverse (): n} função z (e, t, o, n) {var i = e.match (/ ((?: \ - | \ +)? \ d * \.? \ d *) (. *) /), r = + i [1] , p = i [2]; if (! r) retorna e; if (0 === p.indexOf ('%')) {var s; switch (p) {case '% p': s = o; break; case '%': case '% r': padrão: s = n;} var d = c (s); retorno d [t] / 100 * r} if ('vh' === p || ' vw '=== p) {var a; retornar a =' vh '=== p? Q (document.documentElement.clientHeight, window.innerHeight || 0): Q (document.documentElement.clientWidth, window.innerWidth | | 0), a / 100 * r} retorna r} função G (e, t, o, n) {vari = [0,0], r = -1! == ['direita', 'esquerda'] .indexOf (n), p = e.split (/ (\ + | \ -) ​​/). map (função (e) {return e.trim ()}), s = p.indexOf (D (p,função (e) {return-1! == e.search (/, | \ s /)})); p [s] && - 1 === p [s] .indexOf (',') && console.warn ('Os deslocamentos separados por espaços em branco estão obsoletos, use vírgula (,).'); Var d = / \ s *, \ s * | \ s + /, a = -1 === s? [ p]: [p. fatia (0, s) .concat ([p [s]. split (d) [0]]), [p [s]. split (d) [1]]. concat (p. fatia (s + 1))]; retorna a = a.map (função (e, n) {var i = (1 === n?! r: r)? 'height': 'width', p =! 1; return e.reduce (function (e, t) {return '' === e [e.length-1] && - 1! == ['+', '-']. IndexOf (t)? ( e [e.length-1] = t, p =! 0, e): p? (e [e.length-1] + = t, p =! 1, e): e.concat (t)}, []). map (função (e) {retorna z (e, i, t, o)})}), a.forEach (função (e, t) {e.forEach (função (o, n) {U (o) && (i [t] + = o * ('-' === e [n-1]? - 1: 1))})})}), i} função _ (e, t) {var o , n = t.offset, i = e.placement, r = e.offsets, p = r.popper, s = r.reference, d = i.split ('-') [0]; return o = U ( + n)? [+ n, 0]:G (n, p, s, d), 'esquerda' === d? (P.top + = o [0], p.left- = o [1]): 'direita' === d? (P .top + = o [0], p.left + = o [1]): 'top' === d? (p.left + = o [0], p.top- = o [1]): 'bottom' === d && (p.left + = o [0], p.top + = o [1]), e.popper = p, e} para (var X = Math.min, J = Math.floor, Q = Math .max, Z = 'undefined'! = typeof window && 'undefined'! = typeof document, $ = ['Edge', 'Trident', 'Firefox'], ee = 0, te = 0; te <$. length; te + = 1) if (Z && 0 <= navigator.userAgent.indexOf ($ [te])) {ee = 1; break} var i = janela Z &&.Promessa, oe = i? function (e) {var t =! 1; return function () {t || (t =! 0, window.Promise.resolve (). then (function () {t =! 1, e ()}))}}: function (e) {var t = ! 1; return function () {t || (t =! 0, setTimeout (function () {t =! 1, e ()}, ee))}}, ne = {}, ie = function () { var e = 0 <argumentos.length && void 0! == argumentos [0]? argumentos [0]: 'todos'; return (e = e.toString (), ne.hasOwnProperty (e))? ne [e] :( '11' === e? ne [e] = - 1! == navigator.userAgent.indexOf ('Tridente'): '10' === e? ne [e] = - 1! == navigator.appVersion.indexOf ('MSIE 10'): 'todos' === e? ne [e] = - 1! == navigator.userAgent.indexOf ('Trident') | | -1! == navigator.userAgent.indexOf ('MSIE'): void 0, ne.all = ne.all || Object.keys (ne) .some (function (e) {return ne [e]}) , ne [e])}, re = function (e, t) {if (! (instance of t)) lança novo TypeError ('Não é possível chamar uma classe como função')}, pe = function () {function e (e, t) {para (var o, n = 0; n <comprimento t; n ++) o = t [n], o.enumerable = o.enumerable ||! 1, o.configurable =! 0, ' value'in o && (o.writable =! 0), Object.defineProperty (e, o.key, o)} função de retorno (t, o, n) {return o && e (t.prototype, o), n && e (t, n), t}} (), se = função (e, t, o) {retorna t em e? Object.defineProperty (e, t, {valor: o, enumerável:! 0, configurável:! 0,gravável:! 0}): e [t] = o, e}, de = Object.assign || função (e) {for (var t, o = 1; o <argumentos.length; o ++) for (var n em t = argumentos [o], t) Object.prototype.hasOwnProperty.call (t, n) && (e [n] = t [n]); return e}, ae = ['auto-start', 'auto ',' final automático ',' início inicial ',' início ',' início final ',' início inicial ',' direito ',' final final ',' final final ',' final ', 'bottom-start', 'left-end', 'left', 'left-start'], le = ae.slice (3), fe = {FLIP: 'flip', CLOCKWISE: 'sentido horário', COUNTERCLOCKWISE: ' sentido anti-horário '}, me = função () {função t (o, n) {vari = isso, r = 2 <argumentos.length && void 0! == argumentos [2]? argumentos [2]: {}; re (isso , t), this.scheduleUpdate = function () {return requestAnimationFrame (i.update)}, this.update = oe (this.update.bind (this)), this.options = de ({}, t.Defaults,r), this.state = {isDestroyed:! 1, isCreated:! 1, scrollParents: []}, this.reference = o && o.jquery? o [0]: o, this.popper = n && n.jquery? n [0 ]: n, this.options.modifiers = {}, Object.keys (de ({}, t.Defaults.modifiers, r.modifiers)). forEach (função (e) {i.options.modifiers [e] = de ({}, t.Defaults.modifiers [e] || {}, r.modifiers? r.modifiers [e]: {})}), this.modifiers = Object.keys (this.options.modifiers). map (function (e) {return de ({name: e}, i.options.modifiers [e])}). sort (function (e, t) {return e.order-t.order}), isto. modifiers.forEach (function (t) {t.enabled && (t.onLoad) && t.onLoad (i.reference, i.popper, i.options, t, i.state)}), this.update (); var p = this.options.eventsEnabled; p && this.enableEventListeners (), this.state.eventsEnabled = p} retorna pe (t, [{key: 'update', value: function () {return k.call (this)}}, {chave: 'destruir', valor: função () {retornar B.call (this)}}, {key: 'enableEventListeners', value: function () {return M.call (this)}}, {key: 'disableEventListeners', value: function () {return R.call (this) }}]), t} (); retorna me.Utils = ('indefinido' == tipo de janela? global: janela) .PopperUtils, me.placements = ae, me.Defaults = {posicionamento: 'inferior', positionFixed: ! 1, eventsEnabled:! 0, removeOnDestroy:! 1, onCreate: function () {}, onUpdate: function () {}, modificadores: {shift: {order: 100, enabled:! 0, fn: function (e) {var t = e.placement, o = t.split ('-') [0], n = t.split ('-') [1]; se (n) {var i = e.offsets, r = i.reference, p = i.popper, s = -1! == ['bottom', 'top']. indexOf (o), d = s? 'left': 'top', a = s? 'largura ':' height ', l = {start: se ({}, d, r [d]), end: se ({}, d, r [d] + r [a] -p [a])}; e.offsets.popper = de ({}, p, l [n])} retornar e}}, deslocamento: {order: 200, ativado:! 0, fn: _, offset: 0}, preventOverflow: {order:300, ativado:! 0, fn: function (e, t) {var o = t.boundariesElement || r (e.instance.popper); e.instance.reference === o && (o = r (o)) ; var n = E (e.instance.popper, e.instance.reference, t.padding, o, e.positionFixed); t.boundaries = n; vari = t.priority, p = e.offsets.popper, s = {primária: função (e) {var o = p [e]; retorno p [e] <n [e] &&! t.escapeWithReference && (o = Q (p [e], n [e])), se ({}, e, o)}, secundário: function (e) {var o = 'right' === e? 'left': 'top', i = p [o]; return p [e]> n [e] &&! t.escapeWithReference && (i = X (p [o], n [e] - ('right' === e? p.width: p.height))), se ({}, o , i)}}; return i.forEach (function (e) {var t = -1 === ['left', 'top']. indexOf (e)? 'secundário': 'primário'; p = de ({}, p, s [t] (e))}), e.offsets.popper = p, e}, prioridade: ['left', 'right', 'top', 'bottom'], preenchimento: 5, limitesElement: 'scrollParent '}, keepTogether: {order: 400, enabled:! 0, fn: function (e) {var t = e.offsets, o = t.popper, n = t.reference, i = e.placement.split ( '-') [0], r = J, p = -1! == ['top', 'bottom']. IndexOf (i), s = p? 'Right': 'bottom', d = p? 'left': 'top', a = p? 'width': 'height'; return o [s] <r (n [d]) && (e.offsets.popper [d] = r (n [d] ) -o [a]), o [d]> r (n [s]) && (e.offsets.popper [d] = r (n [s])), e}}, seta: {order: 500 , habilitado:! 0, fn: function (e, o) {var n; if (! q (modificadores de instância e ', seta', 'keepTogether')) return e; var i = o.element; if ( 'string' == tipo de i) {if (i = e.instance.popper.querySelector (i) ,! i) retorna e;} else if (! e.instance.popper.contains (i)) retorna console.warn ('WARNING: `arrow.element` deve ser filho de seu elemento popper!'), E; var r = e.placement.split ('-') [0], p = e.offsets, s = p.popper ,d = p.referência, a = -1! == ['esquerda', 'direita']. indexOf (r), l = a? 'height': 'width', f = a? 'Top': 'Left ', m = f.toLowerCase (), h = a?' esquerda ':' superior ', g = a?' inferior ':' direita ', u = L (i) [l]; d [g] -u <s [m] && (e.offsets.popper [m] - = s [m] - (d [g] -u)), d [m] + u> s [g] && (e.offsets.popper [m] + = d [m] + us [g]), e.offsets.popper = c (e.offsets.popper); var b = d [m] + d [l] / 2-u / 2, y = t (e.instância.popper), w = parseFloat (y ['margem' + f], 10), E = parseFloat (y ['borda' + f + 'Largura'], 10), v = be. offsets.popper [m] -wE; return v = Q (X (s [l] -u, v), 0), e.arrowElement = i, e.offsets.arrow = (n = {}, se (n , m, Math.round (v)), se (n, h, ''), n), e}, elemento: '[x-arrow]'}, flip: {order: 600, enabled:! 0, fn: function (e, t) {if (P (modificadores de instância, 'interior')) retorna e; if (e.flipped && e.placement === e.originalPlacement) return e;var o = E (e.instance.popper, e.instance.reference, t.padding, t.boundariesElement, e.positionFixed), n = e.placement.split ('-') [0], i = S ( n), r = e.placement.split ('-') [1] || '', p = []; switch (t.behavior) {case fe.FLIP: p = [n, i]; break; case fe.CLOCKWISE: p = V (n); break; case fe.COUNTERCLOCKWISE: p = V (n,! 0); break; default; p = comportamento t;} return p.forEach (function (s, d ) {if (n! == s || p.length === d + 1) return e; n = e.placement.split ('-') [0], i = S (n); var a = e.offsets.popper, l = e.offsets.reference, f = J, m = 'left' === n && f (a.right)> f (l.left) || 'right' === n && f (a .left) <f (l.right) || 'top' === n && f (a.bottom)> f (l.top) || 'bottom' === n && f (a.top) <f (l. abaixo), h = f (a esquerda) <f (o esquerdo), c = f (a direita)> f (o direito), g = f (a.top) <f (o.top) , u = f (a.bottom)> f (o.bottom), b = 'esquerda' === n && h || 'direita'=== n && c || 'top' === n && g || 'bottom' === n && u, y = -1! == ['top', 'bottom']. indexOf (n), w = !! t .flipVariations && (y && 'start' === r && h || y && 'end' === r && c ||! y && 'start' === r && g ||! y && 'end' === r && u); (m || b || w) && (e.flipped =! 0, (m || b) && (n = p [d + 1]), w && (r = K (r)), e.placement = n + (r? ' - '+ r:' '), e.offsets.popper = de ({}, e.offsets.popper, T (e.instance.popper, e.offsets.reference, e.placement)), e = N ( e.instance.modifiers, e, 'flip'))}), e}, comportamento: 'flip', padding: 5, boundariesElement: 'viewport'}, inner: {order: 700, enabled:! 1, fn: função (e) {var t = e.placement, o = t.split ('-') [0], n = e.offsets, i = n.popper, r = n.reference, p = -1! = = ['esquerda', 'direita']. indexOf (o), s = -1 === ['top ',' left ']. indexOf (o); return i [p?' left ':' top '] = r [o] - (s? i [p?' width ':' height ']: 0) , e.placement = S (t), e.offsets.popper = c (i), e}}, ocultar: {order: 800, enabled:! 0, fn: function (e) {if (! q (e .instance.modifiers, 'hide', 'preventOverflow')) return e; var t = e.offsets.reference, o = D (e.instance.modifiers, function (e) {return'preventOverflow '=== e. nome}). limites; if (t.bottom <o.top || t.left> o.right || t.top> o.bottom || t.right <o.left) {if (! 0 == = e.hide) return e; e.hide =! 0, e.attributes ['x fora dos limites'] = ''} else {if (! 1 === e.hide) return e; e .hide =! 1, e.attributes ['x-fora dos limites'] =! 1} retorna e}}, computeStyle: {order: 850, enabled:! 0, fn: function (e, t) { var o = tx, n = ty, i = e.offsets.popper, p = D (modificadores e instâncias, função (e) {return'applyStyle '=== e.name}). gpuAcceleration; void 0!== p && console.warn (a opção 'WARNING: `gpuAcceleration` mudou para o modificador` computeStyle` e não será suportada em versões futuras do Popper.js!'); var s, d, a = void 0 === p? t .gpuAcceleration: p, l = r (e.instance.popper), f = g (l), m = {position: i.position}, h = {left: J (i.left), em cima: J (i .top), inferior: J (i.bottom), direita: J (direita)}, c = 'bottom' === o? 'top': 'bottom', u = 'right' === n ? 'left': 'right', b = W ('transform'); if (d = 'bottom' == c? -f.height + h.bottom: h.top, s = 'right' == u ? -f.width + h.right: h.left, a && b) m [b] = 'translate3d (' + s + 'px,' + d + 'px, 0)', m [c] = 0, m [u ] = 0, m.willChange = 'transform'; else {var y = 'bottom' == c? -1: 1, w = 'right' == u? -1: 1; m [c] = d * y, m [u] = s * w, m.willChange = c + ',' + u} var E = {"x-placement": e.placement}; retornar e.attributes = de ({}, E,e.attributes), e.styles = de ({}, m, e.styles), e.arrowStyles = de ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x : 'bottom', y: 'right'}, applyStyle: {order: 900, enabled:! 0, fn: function (e) {retorna Y (e.instance.popper, e.styles), j (e.instance .popper, e.tributes), e.arrowElement && Object.keys (e.arrowStyles) .length && Y (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = O (i, t, e, o.positionFixed), p = x (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); retorne t.setAttribute ( 'colocação x', p), Y (t, {posição: o.positionFixed? 'fixo': 'absoluto'}), o}, gpuAcceleration: void 0}}}, me});função (e) {retornar Y (e.instance.popper, e.styles), j (e.instance.popper, e.tributes), e.arrowElement && Object.keys (e.arrowStyles) .length && (e.arrowElement, e .arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = O (i, t, e, o.positionFixed), p = x (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute ('posicionamento x', p), Y (t, {position: o.positionFixed? 'fixed': 'absolute '}), o}, gpuAcceleration: void 0}}}, me});função (e) {retornar Y (e.instance.popper, e.styles), j (e.instance.popper, e.tributes), e.arrowElement && Object.keys (e.arrowStyles) .length && (e.arrowElement, e .arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = O (i, t, e, o.positionFixed), p = x (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute ('posicionamento x', p), Y (t, {position: o.positionFixed? 'fixed': 'absolute '}), o}, gpuAcceleration: void 0}}}, me});positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, me});positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, me});
// # sourceMappingURL = popper.min.js.map